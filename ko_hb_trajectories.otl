= V4 Outline MultiLine NoSorting TabWidth=30

H="First Heading"
/* 
********************HEADING******************** 

Project Name: Homebound Trajectories

Date Started: 12/4/2019

Primary Investigator: Katherine Ornstein
Funding Source:

Created by: MH

Primary Analyst: MH
Secondary Analyst: EBL

Datasets Used: NHATS

Simple Outline: Using NHATS data to further homebound R01. Using homebound and income idea, we look at what happens after the incident homebound stay. 


*/
 
//STATA
// Global Macros use $ symbol to be called. 

//Intermediate Data Path
//global intpath "E:\nhats\data\Projects\..."

// Final Data Path
global datapath "D:\NHATS\Shared\base_data\NHATS cleaned"

//Log files path
global logpath "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"


H="Homebound decision matrix"
/*

Created by: MH
Date Created: 12/19/2019

Updated by:
Date Updated:

Description: Inital data setup for homebound trajectories we are following people 
homebound status. 



**************************************************
*/
local date = subinstr("$S_DATE"," ","_",.) 
local name ko_hb_traj_`date'
di "`name'"

capture log close 
clear all

set more off
version 12
set linesize 80


cd ${logpath}
log using `name'.smcl, text replace

********

use "${datapath}\sp_round_1_8.dta" if lml==0, clear

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015



//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

bys spid wave: egen tot_hlp_hrs=sum(tot_hrswk_help_i) 


sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres

gen homebound_semi=0 if !missing(homebound_cat) & !nhres
replace homebound_semi=1 if inlist(homebound_cat, 2, 3) & !nhres

gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1 
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 
label values status status
label var status "Status this wave"

//checking to make sure everyone has a status at wave 1
sort spid wave
by spid: gen start=1 if wave==1 & status!=.
by spid: carryforward start, replace

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

drop if mstat==1


sort spid wave
by spid: egen lw=max(wave)
label var lw "Last Time observed"

sort spid wave
gen status_nw=1 if spid==spid[_n+1] & wave+1==wave[_n+1] & sp_ivw[_n+1]==1 & !missing(homebound[_n+1])
replace status_nw=2 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==1
replace status_nw=3 if spid==spid[_n+1] & wave+1==wave[_n+1] & inlist(homebound_cat[_n+1],2,3)
replace status_nw=4 if spid==spid[_n+1] & wave+1==wave[_n+1] & nhres[_n+1]==1
replace status_nw=5 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==1 & lw==wave
replace status_nw=6 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==0 & lw==wave
label define status_nw 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH Resident" 5 "Died" 6 "LFU"
label values status_nw status_nw
label var status_nw "Status next wave"

sort spid wave
by spid: egen hb_min=min(wave) if homebound==1
gen inchb=0
replace inchb=1 if hb_min==wave 

by spid: egen ever_hb=max(hb)

//Looking at the wave right after incident homebound.
gen wave_after_inchb=0
by spid: replace wave_after_inchb=1 if spid[_n+1]==spid & wave[_n+1]==wave+1 & inchb==1
//this really tells if hb in this wave

gen next_wave_com=0
replace next_wave_com=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_hb=0
replace next_wave_hb=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]==1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_semi=0
replace next_wave_semi=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]==1

gen next_wave_nhres=0
replace next_wave_nhres=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==1 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_lfu=0
replace next_wave_lfu=1 if inchb==1 & wave_after_inchb==0 & died_12==0 & spid!=spid[_n+1]

gen wave_after=0
replace wave_after=1 if wave_after_inchb==1

//wave_after_inchb1 is the correct one
gen wave_after_inchb1=0
replace wave_after_inchb1=1 if spid==spid[_n-1] & wave_after_inchb[_n-1]==1 & inchb[_n-1]==1

foreach x in next_wave_com next_wave_hb next_wave_semi next_wave_nhres next_wave_lfu{
tab wave_after_inchb `x'
}


gen a=1 if wave_after_inchb1==1 & independent==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid

tab wave_after_inchb1 help_go_out if next_wave_com[_n-1]==1

gen diff_help_out=0
replace diff_help_out=1 if hasdifficulty==1 | needshelp==1

sort spid wave
gen hb_still=0
replace hb_still=1 if hb_min[_n-1]==hb_min & spid[_n-1]==spid & hb_min!=.

tab wave_after_inchb next_wave_com
tab needshelp if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab hasdifficulty if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab help_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid,m
tab independent if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m

tab freq_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1, m


tab surgery if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1
tab rehab if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab device_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab ind_imp_goout if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_helpers=.
sort spid wave
by spid: replace hb_helpers=n_helpers[_n+1]-n_helpers

tab hb_helpers if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_hours=.
sort spid wave
by spid: replace hb_hours=tot_hlp_hrs[_n+1]-tot_hlp_hrs

tab hb_hours if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

xtset spid wave

tab status status_nw if wave==1, row nofreq 
tab status status_nw if wave==2, row

tab status status_nw if wave==2 & spid[_n-1]==spid & status[_n-1]==2, row

xttrans status if wave==1 | wave==2 , freq


sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace
drop time
sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 

gen hb1=1 if homebound==1 & wave==1

sort spid wave


tab status_nw [aw=anfinw] if time==1 & wave==3

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==2 & wave==3 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}


log close
translate `name'.smcl `name'.pdf
exit



H="Decision Tree matrix"
/*

Created by: MH
Date Created: 12/19/2019

Updated by:
Date Updated:

Description: Inital data setup for homebound trajectories we are following people 
homebound status. 



**************************************************
*/
local date = subinstr("$S_DATE"," ","_",.) 
local name ko_hb_traj_`date'
di "`name'"

capture log close 
clear all

set more off
version 12
set linesize 80


cd ${logpath}
log using `name'.smcl, text replace

********

use "${datapath}\sp_round_1_8.dta" if lml==0, clear

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015



//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

bys spid wave: egen tot_hlp_hrs=sum(tot_hrswk_help_i) 


sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres

gen homebound_semi=0 if !missing(homebound_cat) & !nhres
replace homebound_semi=1 if inlist(homebound_cat, 2, 3) & !nhres

gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1 
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 
label values status status
label var status "Status this wave"

//checking to make sure everyone has a status at wave 1
sort spid wave
by spid: gen start=1 if wave==1 & status!=.
by spid: carryforward start, replace

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

drop if mstat==1


sort spid wave
by spid: egen lw=max(wave)
label var lw "Last Time observed"

sort spid wave
gen status_nw=1 if spid==spid[_n+1] & wave+1==wave[_n+1] & sp_ivw[_n+1]==1 & !missing(homebound[_n+1])
replace status_nw=2 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==1
replace status_nw=3 if spid==spid[_n+1] & wave+1==wave[_n+1] & inlist(homebound_cat[_n+1],2,3)
replace status_nw=4 if spid==spid[_n+1] & wave+1==wave[_n+1] & nhres[_n+1]==1
replace status_nw=5 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==1 & lw==wave
replace status_nw=6 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==0 & lw==wave
label define status_nw 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH Resident" 5 "Died" 6 "LFU"
label values status_nw status_nw
label var status_nw "Status next wave"

sort spid wave
by spid: egen hb_min=min(wave) if homebound==1
gen inchb=0
replace inchb=1 if hb_min==wave 

by spid: egen ever_hb=max(hb)

//Looking at the wave right after incident homebound.
gen wave_after_inchb=0
by spid: replace wave_after_inchb=1 if spid[_n+1]==spid & wave[_n+1]==wave+1 & inchb==1
//this really tells if hb in this wave

gen next_wave_com=0
replace next_wave_com=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_hb=0
replace next_wave_hb=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]==1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_semi=0
replace next_wave_semi=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]==1

gen next_wave_nhres=0
replace next_wave_nhres=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==1 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_lfu=0
replace next_wave_lfu=1 if inchb==1 & wave_after_inchb==0 & died_12==0 & spid!=spid[_n+1]

gen wave_after=0
replace wave_after=1 if wave_after_inchb==1

//wave_after_inchb1 is the correct one
gen wave_after_inchb1=0
replace wave_after_inchb1=1 if spid==spid[_n-1] & wave_after_inchb[_n-1]==1 & inchb[_n-1]==1

foreach x in next_wave_com next_wave_hb next_wave_semi next_wave_nhres next_wave_lfu{
tab wave_after_inchb `x'
}


gen a=1 if wave_after_inchb1==1 & independent==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid

tab wave_after_inchb1 help_go_out if next_wave_com[_n-1]==1

gen diff_help_out=0
replace diff_help_out=1 if hasdifficulty==1 | needshelp==1

sort spid wave
gen hb_still=0
replace hb_still=1 if hb_min[_n-1]==hb_min & spid[_n-1]==spid & hb_min!=.

tab wave_after_inchb next_wave_com
tab needshelp if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab hasdifficulty if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab help_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid,m
tab independent if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m

tab freq_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1, m


tab surgery if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1
tab rehab if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab device_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab ind_imp_goout if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_helpers=.
sort spid wave
by spid: replace hb_helpers=n_helpers[_n+1]-n_helpers

tab hb_helpers if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_hours=.
sort spid wave
by spid: replace hb_hours=tot_hlp_hrs[_n+1]-tot_hlp_hrs

tab hb_hours if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

xtset spid wave

tab status status_nw if wave==1, row nofreq 
tab status status_nw if wave==2, row

tab status status_nw if wave==2 & spid[_n-1]==spid & status[_n-1]==2, row

xttrans status if wave==1 | wave==2 , freq


sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace
drop time
sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 

gen hb1=1 if homebound==1 & wave==1

sort spid wave


tab status_nw [aw=anfinw] if time==1 & wave==3

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==2 & wave==3 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==4 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}






log close
translate `name'.smcl `name'.pdf
exit



H="Follow wave 2 incident hb"
//Part 1

clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2

gen nothbw1=.
replace nothbw1=1 if wave==1 & status!=2
sort spid wave
by spid: carryforward nothbw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if nothbw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.



sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 


sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

keep if wave==2

/*
stset lw [pw=anfinw], failure(f_stat==1) id(spid)

sts graph, note(fail=community dwelling)

stset lw [pw=anfinw], failure(f_stat==2) id(spid)

sts graph, note(fail=semi-homebound)

stset lw [pw=anfinw], failure(f_stat==3) id(spid)

sts graph, note(fail=nhres)

stset lw [pw=anfinw], failure(f_stat==4) id(spid)

sts graph, note(fail=death)

stset lw [pw=anfinw], failure(f_stat==1 2 3 4) id(spid)

sts graph, note(fail=all)
*/

stset lw [pw=anfinw], failure(f_stat==1) id(spid)
sts gen s2=s 
stset lw [pw=anfinw], failure(f_stat==2) id(spid)
sts gen s3=s
stset lw [pw=anfinw], failure(f_stat==3) id(spid)
sts gen s4=s 
stset lw [pw=anfinw], failure(f_stat==4) id(spid)
sts graph, addplot((line s2 lw, sort c(J) legend( order( 1 "Died" 2 "Community" 3 "Semi-Homebound" 4 "NH")))(line s3 lw, sort c(J)) (line s4 lw, sort c(J)))

drop a
gen sample_full=.
replace sample_full=1 if sample==1 & status==2

drop if sample_full==.



replace adl_diff_ind=1 if adl_impair==1
label var adl_diff_ind "ADL difficulty or impairment"

tab status nwstatus if wave==1, m




sort spid wave
/*gen northeast=region==1
gen midwest=region==2
gen south=region==3
gen west=region==4
label var northe "Northeast"
label var midw "Midwest"
label var south "South"
label var west "West"*/
gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}


tab wave nwstat if wave<=4, row
tab nwsta status if wave==1 

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}
/*label define income_quart 1 "1st Income Quartile (Low)" 2 "2nd Income Quartile" ///
3 "3rd Income Quartile" 4 "4th Income Quartile (Highest)"
label values income_quart income_quart*/



gen prob_dementia=dem_3==1 if !missing(dem_3)
label var prob_dementia "Probable dementia"

by spid, sort: gen persontime=_N
replace persontime=firsthb if firsthb<persontime
replace persontime=firstnh if firstnh<persontime
label var persontime "Waves contributing information"
gen anydebt=creditdebt==1 | medpayno==1 if !missing(creditdebt) | !missing(medpayn)
label var anydebt "Credit card or medical debt"



sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace

sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 






//important to define the last wave in community 
sort spid wave
by spid: egen lw=max(wave)
replace lw=lw-1
label var lw "Last Time in the Community"




H="Change log"


********************Change Log******************** 



Updates:

01/13/2020 MH
------------
Adding in code to follow people who were incident homebound in wave 2 and then running KM curves. 

01/06/2020 MH
------------
Following tracjectories of people who are Incident HB.

12/17/2019 MH
------------
Adding in semi-homebound and creating tables for what happens after incident homebound. 

12/5/2019 MH
------------
Working on trajectories and creating varaibles to see what happens to a person after their incident homebound wave. 



*/